# 核心模块源码剖析

## namesrv

### Namesrv 启动流程

![Namesrv 启动流程](./assets/第二阶段/Namesrv 启动流程.png)



### rocketmq-namesrv 最需要掌握什么？来看看AI是如何总结的

在 RocketMQ 5.3.3 中学习 **Name Server（namesrv）** 模块时，最需要掌握的核心内容应聚焦于其**架构定位、核心职责、关键机制与高可用设计**。Name Server 是 RocketMQ 的“注册中心”和“路由中枢”，虽轻量但极其关键。以下是学习时必须掌握的要点，按优先级排序：

------

#### ✅ 一、核心定位与作用（Why Name Server?）

##### 必须理解：

- Name Server 是无状态、去中心化的注册中心
  - 不存储消息，只管理 **Topic 路由信息（Broker 地址、队列分布）**
  - Producer/Consumer 通过 Name Server 获取 Broker 列表，之后直接与 Broker 通信
- 解耦 Producer/Consumer 与 Broker
  - 新增/下线 Broker 时，只需向 Name Server 注册/注销，客户端自动感知
- **对比 ZooKeeper**：RocketMQ 为何不用 ZK？
  → 因 Name Server 更轻量、无选举开销、满足最终一致性即可

> 📌 **一句话总结**：Name Server = RocketMQ 的“电话簿”，告诉客户端“去哪找 Broker”。

------

#### ✅ 二、核心工作机制（How It Works?）

##### 1. **路由注册（Register）**

- **Broker 启动时**，向**所有 Name Server** 发送 `REGISTER_BROKER` 请求（含 Topic 配置、读写队列数、IP 端口等）
- Name Server 将路由信息存入内存 `ConcurrentHashMap<String/* topic */, TopicRouteData>`
- **每 30 秒 Broker 心跳续期**（防止 Name Server 清理）

##### 2. **路由发现（Discovery）**

- **Producer/Consumer 启动时**，从 Name Server 列表随机选一个，拉取全量路由信息
- **每 30 秒定时更新**（`DefaultMQPushConsumer` 默认 30s，可配）
- 客户端本地缓存路由，发送消息时直接查本地缓存

##### 3. **路由剔除（Cleanup）**

- Name Server 启动后台线程（`RouteInfoManager#scanNotActiveBroker`）
- **若 Broker 超过 120 秒未心跳**（2 × 心跳间隔），则从路由表移除
- **注意**：Name Server **不主动通知**客户端，靠客户端下次拉取时感知

> 🔑 **关键参数**（`NamesrvConfig`）：
>
> - `scanNotActiveBrokerInterval` = 5s（扫描间隔），参见方法：org.apache.rocketmq.namesrv.NamesrvController#startScheduleService
> - `brokerLiveCheckInterval` = 120s（超时阈值），参见常量：org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#DEFAULT_BROKER_CHANNEL_EXPIRED_TIME

------

#### ✅ 三、高可用与部署模式（HA Design）

##### 必须掌握：

- Name Server 集群无主从、无数据同步

  - 每个节点独立工作，数据最终一致（靠 Broker 向所有节点注册）

- 客户端配置多个 Name Server 地址（逗号分隔）

  ```java
  producer.setNamesrvAddr("ns1:9876;ns2:9876;ns3:9876");
  ```

- 容错机制：

  - 若某个 Name Server 不可用，客户端自动切换到下一个
  - **只要有一个 Name Server 可用，集群就可用**

> ⚠️ **重要限制**：
>  Name Server **不保证强一致性**！Broker 注册可能因网络延迟导致短暂不一致，但 RocketMQ 通过客户端重试+多 Name Server 配置容忍此问题。

------

#### ✅ 四、关键源码模块（RocketMQ 5.3.3）

学习时重点阅读以下包（`rocketmq-namesrv` 模块）：

| 类/包                                                        | 作用         | 学习重点                                                |
| ------------------------------------------------------------ | ------------ | ------------------------------------------------------- |
| `org.apache.rocketmq.namesrv.NamesrvStartup`                 | 启动入口     | 初始化 `NamesrvController`                              |
| `org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager`     | **核心类！** | 路由注册/查询/剔除逻辑                                  |
| `org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor` | 请求处理器   | 处理 `GET_ROUTEINTO_BY_TOPIC`, `REGISTER_BROKER` 等命令 |
| `org.apache.rocketmq.common.namesrv.NamesrvConfig`           | 配置类       | 超时时间、存储路径等                                    |

> 💡 **调试建议**：
>  在 `org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#registerBroker` 和 `org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#scanNotActiveBroker` 打断点，观察路由注册与清理过程。

------

#### ✅ 五、常见问题与最佳实践

##### 必须知道的坑：

1. **Name Server 宕机影响？**
   - 已运行的 Producer/Consumer **不受影响**（因本地有缓存）
   - **新启动的客户端无法获取路由** → 业务中断 → **结论：Name Server 至少部署 2 节点**
2. **为什么 Broker 要向所有 Name Server 注册？**
    → 避免单点故障，保证每个 Name Server 数据完整
3. **路由更新延迟？**
   - 最大延迟 = 客户端拉取间隔（默认 30s） + Name Server 剔除延迟（120s）
     → 敏感场景可调小 `pollNameServerInterval`
4. **Name Server 内存占用？**
   - 路由信息全在内存，10万 Topic 约占 100~200MB
     → 监控 `jstat -gc` 防止 OOM

------

#### ✅ 六、与旧版本差异（5.x vs 4.x）

RocketMQ 5.x 对 Name Server **改动极小**（因其设计已很成熟），但需注意：

- **5.x 强化了可观测性**：增加 Metrics 指标（如 `route_info_count`）
- **配置简化**：移除部分冗余参数
- **与 Proxy 架构协同**：在 5.x 的“逻辑隔离”架构中，Name Server 仍负责物理 Broker 路由

> 📌 **学习建议**：Name Server 机制在 4.x/5.x 基本一致，掌握 5.3.3 即覆盖主流版本。

------

#### ✅ 总结：最需要掌握的 5 个核心点

| 优先级  | 内容                                                         | 为什么重要               |
| ------- | ------------------------------------------------------------ | ------------------------ |
| 🔴 **1** | **Name Server 是无状态注册中心，只管路由不管消息**           | 理解 RocketMQ 架构基石   |
| 🔴 **2** | **Broker 向所有 Name Server 注册，客户端从任一节点拉取路由** | 掌握高可用实现原理       |
| 🔴 **3** | **路由注册（30s 心跳）、剔除（120s 超时）、客户端拉取（30s）三大周期** | 解释生产环境路由延迟问题 |
| 🟠 **4** | **Name Server 宕机不影响已运行客户端，但阻塞新客户端启动**   | 运维排障关键知识         |
| 🟢 **5** | **核心类 `RouteInfoManager` 的注册/查询/清理逻辑**           | 深入源码必备             |

------

> 💡 **终极建议**：
>  **动手实验 > 死记理论**！
>
> 1. 启动 2 个 Name Server + 1 Broker
>
> 2. 用 `mqadmin topicList -n 127.0.0.1:9876` 查看路由
>
>    ```basic
>    :: 打开cmd
>    :: 进入bin目录
>    cd E:\DiGuaPao\Github\apache\rocketmq\rocketmq-all-5.3.3-bin-release\bin
>    :: 临时设置环境变量（当前命令行有效）
>    set ROCKETMQ_HOME=E:\DiGuaPao\Github\apache\rocketmq\rocketmq-all-5.3.3-bin-release
>    set JAVA_HOME=E:\soft\jdk1.8\jdk1.8.0_221
>    :: 查看集群列表
>    mqadmin.cmd clusterList -n 127.0.0.1:9876
>    ```
>
> 3. 停掉一个 Name Server，观察客户端是否正常
>
> 4. 修改 Broker 配置后重启，验证路由更新延迟
>
> 通过实践，你会真正掌握 Name Server 的“灵魂”。